import random
from typing import List
import node_group


class Node:
    # Class variable to store instances
    all_instances_by_id: dict[str, 'Node'] = {}
    def __init__(self, group: 'node_group.NodeGroup'):
        self.node_id: str = f'{group.group_id}-{group.node_id_counter}'  # auto set new id
        group.node_id_counter += 1
        self.group: 'node_group.NodeGroup' = group
        self.connections: List[str] = []  # node ids this node is connected to
        self.infected: bool = False
        self.num_of_infections: int = 0
        # other properties, eg. infected, was infected x times, etc.
        Node.all_instances_by_id[self.node_id] = self
        self.available_connections = -1 # Randomly generated by the group

    @property
    def siblings(self) -> List['Node']:
        # TODO do you want a list of nodes?
        connection_nodes: list['Node'] = []
        for connection in self.connections:
            connection_nodes.append(Node.all_instances_by_id[connection])
        # return all siblings from parent group
        return connection_nodes

    def get_num_of_connections(self) -> int:
        return len(self.connections)

    def is_fully_connected(self) -> bool:
        if self.available_connections == -1:
            return False # If this number is -1 the all connections have been established
        return self.available_connections == 0

    def add_connection(self, node_id: str, added_on_target: bool = False) -> bool:
        if node_id not in Node.all_instances_by_id.keys():
            return False
        if node_id in self.connections:
            return False
        self.connections.append(node_id)
        if not added_on_target:
            Node.all_instances_by_id[node_id].add_connection(self.node_id, added_on_target=True)
        self.available_connections -= 1
        return True



    def has_connection(self, node_id: str) -> bool:
        if node_id in self.connections:
            return True
        return False

    def remove_connection(self, node_id: str, removed_on_target: bool = False) -> bool:
        if node_id not in Node.all_instances_by_id.keys():
            return False
        if node_id not in self.connections:
            return False
        self.connections.remove(node_id)
        if not removed_on_target:
            Node.all_instances_by_id[node_id].remove_connection(self.node_id, removed_on_target=True)
        self.available_connections += 1
        return True

    def clear_connections(self) -> None:
        for connection in self.connections.copy():
            self.remove_connection(connection)
        self.available_connections = -1
        # TODO should the available_connections variable also reset back to -1? If not after a reset the noes will ahve the same amount of connections

    def infect_node(self) -> None:
        self.infected = True
        self.num_of_infections += 1

    def cure_node(self) -> None:
        self.infected = False

    def __str__(self):
        return f'ID: {self.node_id}, Connections: {self.connections}'
